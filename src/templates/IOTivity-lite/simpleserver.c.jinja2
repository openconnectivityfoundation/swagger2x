/*
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 Copyright 2017-2021 Open Connectivity Foundation
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/
#ifndef DOXYGEN
// Force doxygen to document static inline
#define STATIC static
#endif

/**
 * @file
 *  Generated Code
 */
/**
 * ## Application Design
 *
 * support functions:
 *
 * - app_init
 *   initializes the oic/p and oic/d values.
 * - register_resources
 *   function that registers all endpoints, e.g. sets the RETRIEVE/UPDATE/DELETE handlers for each end point
 *
 * - main 
 *   starts the stack, with the registered resources.
 *   can be compiled out with NO_MAIN
 *
 * Each resource has:
 *  - global property variables (per resource path) for:
 *    - the property name
 *       naming convention: g_[path]_RESOURCE_PROPERTY_NAME_[propertyname]
 *    - the actual value of the property, which is typed from the json data type
 *      naming convention: g_[path]_[propertyname]
 *  - global resource variables (per path) for:
 *    - the path in a variable:
 *      naming convention: g_[path]_RESOURCE_ENDPOINT
 *
 *  handlers for the implemented methods (get/post):
 *   - get_[path]
 *     function that is being called when a RETRIEVE is called on [path]
 *     set the global variables in the output
 *   - post_[path]
 *     function that is being called when a UPDATE is called on [path]
 *     checks the input data
 *     if input data is correct
 *       updates the global variables
 *
 * ## IoTivity specific defines
 *
 *  - OC_SECURITY 
      enable security
 *    - OC_PKI 
 *      enable use of PKI, note onboarding is enabled by means of run time code
 *    - OC_SECURITY_PIN 
 *      enables Random PIN onboarding, 
 *  - OC_CLOUD 
 *    enables cloud access
 *  - OC_IDD_API 
 *    IDD via API, otherwise use header file to define the IDD
 * - __linux__ 
 *   build for linux
 * - WIN32 
 *   build for windows
 *
 * ## File specific defines
 *
 * - NO_MAIN
 *   compile out the function main()
 * - INCLUDE_EXTERNAL
 *   includes header file "external_header.h", so that other tools/dependencies can be included without changing this code
 * - INCLUDE_EXTERNAL_FUNCTION
 *   includes header file "external_header.h", so that other tools/dependencies can be included without changing this code
 *   calls function void external_registration(void) during 
 * - OPTIMIZE_PSTAT
 *   disable PSTAT observe
 */
/*
 tool_version          : {{version}}
 input_file            : {{input_file}}
 version of input_file : {{json_data['info']['version']}}
 title of input_file   : {{json_data['info']['title']}}
*/

#include "oc_api.h"
#include "oc_core_res.h"
#include "port/oc_clock.h"
#include <signal.h>

#ifdef OC_CLOUD
#include "oc_cloud.h"
#endif
#if defined(OC_IDD_API)
#include "oc_introspection.h"
#endif

#ifdef INCLUDE_EXTERNAL
/* import external definitions from header file*/
/* this file should be externally supplied */
#include "external_header.h"
#endif

#ifdef __linux__
/** linux specific code */
#include <pthread.h>
#ifndef NO_MAIN
static pthread_mutex_t mutex;
static pthread_cond_t cv;
static struct timespec ts;
#endif /* NO_MAIN */
#endif

#ifdef WIN32
/** windows specific code */
#include <windows.h>
STATIC CONDITION_VARIABLE cv;   /**< event loop variable */
STATIC CRITICAL_SECTION cs;     /**< event loop variable */
#endif

#include <stdio.h>  /* defines FILENAME_MAX */
#ifdef WIN32
#include <direct.h>
#define GetCurrentDir _getcwd
#else
#include <unistd.h>
#define GetCurrentDir getcwd
#endif

#define btoa(x) ((x)?"true":"false")

#define MAX_STRING 30           /**< max size of the strings. */
#define MAX_PAYLOAD_STRING 65   /**< max size strings in the payload */
#define MAX_ARRAY 10            /**< max size of the array */
/* Note: Magic numbers are derived from the resource definition, either from the example or the definition.*/

volatile int quit = 0;          /**< stop variable, used by handle_signal */
STATIC const size_t DEVICE = 0; /**< default device index */

{%- macro trans_interfaces(interface) -%}
 {%- if interface == "oic.if.baseline" %} OC_IF_BASELINE
 {%- elif interface == "oic.if.rw" %} OC_IF_RW
 {%- elif interface == "oic.if.r" %} OC_IF_R
 {%- elif interface == "oic.if.s" %} OC_IF_S
 {%- elif interface == "oic.if.a" %} OC_IF_A
 {%- elif interface == "oic.if.b" %} OC_IF_B
 {%- elif interface == "oic.if.ll" %} OC_IF_LL
 {%- elif interface == "oic.if.startup" %} OC_IF_STARTUP
 {%- elif interface == "oic.if.startup.revert" %} OC_IF_STARTUP_REVERT
 {%- elif interface == "oic.if.w" %} OC_IF_W
 {%- else %}
    /* {{interface}} not handled */
 {%- endif %}
{%- endmacro %}

{%- macro create_interfaces(json_data, path) -%}
  {%- set interfaces  = query_if(json_data, path) %}
  {%- for if in interfaces %}
  oc_resource_bind_resource_interface(res{{path|variablesyntax}}, {{trans_interfaces(if)}}); /* {{if}} */
  {%- endfor %}
  oc_resource_set_default_interface(res{{path|variablesyntax}}, {{trans_interfaces(interfaces[0])}});  
  PRINT("     Default OCF Interface: '{{interfaces[0]}}'\n");
{%- endmacro %}


{%- macro get_args(my_data, my_path) -%}
 {%- for var, var_data in query_properties_filtered_get(my_data, my_path).items() -%}
    {{ args(my_data, my_path, var, var_data) }}
 {%- endfor %}
{%- endmacro %}


{%- macro post_args(my_data, my_path) -%}
 {%- for var, var_data in query_properties_filtered_post(my_data, my_path).items() -%}
   {{ args(my_data, my_path, var, var_data) }}
 {%- endfor %}
{%- endmacro %}

{%- macro args(my_data, my_path, var, var_data) -%}
    {%- if var_data.type == "boolean" %}
    /* property (boolean) '{{var}}' */
    oc_rep_set_boolean(root, {{var}}, g{{my_path|variablesyntax}}{{var|variablesyntax}});
    PRINT("   %s : %s\n", g{{my_path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}, (char *)btoa(g{{my_path|variablesyntax}}{{var|variablesyntax}}));
    {%- elif var_data.type == "integer" %}
    /* property (integer) '{{var}}' */
    oc_rep_set_int(root, {{var}}, g{{my_path|variablesyntax}}{{var|variablesyntax}});
    PRINT("   %s : %d\n", g{{my_path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}, g{{my_path|variablesyntax}}{{var|variablesyntax}});
    {%- elif var_data.type == "number" %}
    /* property (number) '{{var}}' */
    oc_rep_set_double(root, {{var}}, g{{my_path|variablesyntax}}{{var|variablesyntax}});
    PRINT("   %s : %f\n", g{{my_path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}, g{{my_path|variablesyntax}}{{var|variablesyntax}});
    {%- elif var_data.type == "string" %}
    /* property (string) '{{var}}' */
    oc_rep_set_text_string(root, {{var}}, g{{my_path|variablesyntax}}{{var|variablesyntax}});
    PRINT("   %s : %s\n", g{{my_path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}, g{{my_path|variablesyntax}}{{var|variablesyntax}});
    {%- elif var_data.type == "array" %}
    {#- all types of arrays #}
    {%- if var_data |convert_to_cplus_array_type == "std::vector<bool>" %}
    /* property (array of strings) '{{var}}' */
    oc_rep_set_array(root, {{var}});
    PRINT("   %s (bool) =[ ", g{{my_path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}});
    for (int i=0; i< (int)g{{my_path|variablesyntax}}{{var|variablesyntax}}_array_size; i++) {
      oc_rep_add_boolean({{var}}, g{{my_path|variablesyntax}}{{var|variablesyntax}}[i]);
      PRINT("   %s ", (char *)btoa(g{{my_path|variablesyntax}}{{var|variablesyntax}}[i]));
    }
    PRINT("   ]\n");
    oc_rep_close_array(root, {{var}});
    {%- elif var_data |convert_to_cplus_array_type == "std::vector<int>" %}
    {%- if is_boolean_array(var_data) == true %}
    /* property (array of bytes) '{{var}}' */
    oc_rep_set_array(root, {{var}});
    PRINT("   %s byte = [ ", g{{my_path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}});
    //oc_rep_add_byte_string({{var}},g{{my_path|variablesyntax}}, g{{my_path|variablesyntax}}{{var|variablesyntax}}_array_size);
    for (int i=0; i< (int)g{{my_path|variablesyntax}}{{var|variablesyntax}}_array_size; i++) {
      oc_rep_add_byte_string({{var}}, g{{my_path|variablesyntax}}{{var|variablesyntax}}[i]);
      PRINT("   %d ", g{{my_path|variablesyntax}}{{var|variablesyntax}}[i]);
    }
    oc_rep_close_array(root, {{var}});
    {%- else %} 
    /* property (array of integers) '{{var}}' */
    oc_rep_set_array(root, {{var}});
    PRINT("   %s int = [ ", g{{my_path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}});
    for (int i=0; i< (int)g{{my_path|variablesyntax}}{{var|variablesyntax}}_array_size; i++) {
      oc_rep_add_int({{var}}, g{{my_path|variablesyntax}}{{var|variablesyntax}}[i]);
      PRINT("   %d ", g{{my_path|variablesyntax}}{{var|variablesyntax}}[i]);
    }
    oc_rep_close_array(root, {{var}});
    {%- endif %} 
    {%- elif var_data |convert_to_cplus_array_type == "std::vector<double>" %}
    /* property (array of numbers) '{{var}}' */
    oc_rep_set_array(root, {{var}});
    PRINT("   %s double = [ ", g{{my_path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}});
    for (int i=0; i< (int)g{{my_path|variablesyntax}}{{var|variablesyntax}}_array_size; i++) {
      oc_rep_add_double({{var}}, g{{my_path|variablesyntax}}{{var|variablesyntax}}[i]);
      PRINT("   %f ", g{{my_path|variablesyntax}}{{var|variablesyntax}}[i]);
    }
    PRINT("   ]\n");
    oc_rep_close_array(root, {{var}});
    {%- elif var_data |convert_to_cplus_array_type == "std::vector<std::string>" %}
    /* property (array of strings) '{{var}}' */
    oc_rep_open_array(root, {{var}});
    PRINT("   %s string = [\n", g{{my_path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}});
    for (int i=0; i< (int)g{{my_path|variablesyntax}}{{var|variablesyntax}}_array_size; i++) {
      oc_rep_add_text_string({{var}}, g{{my_path|variablesyntax}}{{var|variablesyntax}}[i]);
      PRINT("     %s\n ", g{{my_path|variablesyntax}}{{var|variablesyntax}}[i]);
    }
    oc_rep_close_array(root, {{var}});
    {%- elif var_data |convert_to_cplus_array_type == "std::vector<OCRepresentation>" %}
    /* property (array of objects) '{{var}}' */
    PRINT("   Array of objects : '%s'\n", g{{my_path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}});
    oc_rep_set_array(root, {{var}});
    {%- set my_data = var_data |get_c_data() %}
    for (int i = 0; i<g{{my_path|variablesyntax}}{{var|variablesyntax}}_array_size; i++)
    {
      oc_rep_object_array_begin_item({{var}});
    {%- for k,v in my_data.items() %}
      /* {{k}} {{v}} */
{%- if v[0] == "boolean" %}
      oc_rep_set_boolean({{var}}, {{k}}, g{{my_path|variablesyntax}}{{var|variablesyntax}}[i].{{k}});
      PRINT("    (boolean) {{k}} : %d %s\n", i, (char *)btoa(g{{my_path|variablesyntax}}{{var|variablesyntax}}[i].{{k}}));
{%- elif v[0] == "integer" %}
      oc_rep_set_int({{var}}, {{k}}, g{{my_path|variablesyntax}}{{var|variablesyntax}}[i].{{k}});
      PRINT("    int {{k}} : %d %d\n", i, g{{my_path|variablesyntax}}{{var|variablesyntax}}[i].{{k}});
{%- elif v[0] == "number" %}
      oc_rep_set_double({{var}}, {{k}}, g{{my_path|variablesyntax}}{{var|variablesyntax}}[i].{{k}});
      PRINT("    (number) {{k}} : %d %f\n", i, g{{my_path|variablesyntax}}{{var|variablesyntax}}[i].{{k}});
{%- elif v[0] == "string" %}
      oc_rep_set_text_string({{var}}, {{k}}, g{{my_path|variablesyntax}}{{var|variablesyntax}}[i].{{k}});
      PRINT("    string {{k}} : %d %s\n", i, g{{my_path|variablesyntax}}{{var|variablesyntax}}[i].{{k}});
{%- elif v[0] == "string[]" %}
      oc_rep_open_array({{var}}, {{k}});
      PRINT("    array {{k}} \n");
      oc_rep_add_text_string({{k}}, g{{my_path|variablesyntax}}{{var|variablesyntax}}[i].{{k}}[0]);
      PRINT("     array item string {{k}}[0] : %d %s\n", i, g{{my_path|variablesyntax}}{{var|variablesyntax}}[i].{{k}}[0]);
      oc_rep_close_array({{var}}, {{k}});
{% else %}
    /** {{k}} not handled */
{% endif %}
    {%- endfor %}
      oc_rep_object_array_end_item({{var}});
    }
    oc_rep_close_array(root, {{var}});
    {# array handling #}
    {%- endif -%}
    {%- elif var_data.type == "object" %}
    /* property (object) "{{var}}" */
    PRINT("   Object : %s\n", g{{my_path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}});
    oc_rep_set_object(root, {{var}});
    {%- set my_data = var_data.properties |get_c_data() %}
    {%- for k,v in my_data.items() %}
{%- if v[0] == "integer" %}
    oc_rep_set_int({{var}}, {{k}}, g{{my_path|variablesyntax}}{{var|variablesyntax}}.{{k}});
    PRINT("    int {{k}} : %d\n", g{{my_path|variablesyntax}}{{var|variablesyntax}}.{{k}});
{%- elif v[0] == "boolean" %}
    oc_rep_set_boolean({{var}}, {{k}}, g{{my_path|variablesyntax}}{{var|variablesyntax}}.{{k}});
    PRINT("    boolean {{k}} : %s\n", (char *)btoa(g{{my_path|variablesyntax}}{{var|variablesyntax}}.{{k}}));
{%- elif v[0] == "number" %}
    oc_rep_set_double({{var}}, {{k}}, g{{my_path|variablesyntax}}{{var|variablesyntax}}.{{k}});
    PRINT("    number {{k}} : %f\n", g{{my_path|variablesyntax}}{{var|variablesyntax}}.{{k}});
{%- elif v[0] == "string" %}
    oc_rep_set_text_string({{var}}, {{k}}, g{{my_path|variablesyntax}}{{var|variablesyntax}}.{{k}});
    PRINT("    string {{k}} : %s\n", g{{my_path|variablesyntax}}{{var|variablesyntax}}.{{k}});
{%- elif v[0] == "string[]" %}
    oc_rep_open_array({{var}}, {{k}});
    PRINT("    array {{k}} \n"); 
    for (int i = 0; i< g{{my_path|variablesyntax}}{{var|variablesyntax}}.{{k}}_array_size ; i++) {
      oc_rep_add_text_string({{k}}, g{{my_path|variablesyntax}}{{var|variablesyntax}}.{{k}}[i]);
      PRINT("     array item string {{k}}[0] : %s\n", g{{my_path|variablesyntax}}{{var|variablesyntax}}.{{k}}[i]);
    }
    oc_rep_close_array({{var}}, {{k}});
{% else %}
  /* {{k}} not handled */
{% endif %}
    {%- endfor %}
    oc_rep_close_object(root, {{var}});
    {%- endif %}
{%- endmacro %}


{%- macro get_start_args(my_data, my_path) -%}
 {%- for var, var_data in query_properties_filtered(my_data, my_path).items() -%}
    {%- if var_data.type == "boolean" %}
    /* property (boolean) '{{var}}' */
    {
     bool temp{{var|variablesyntax}};
     long temp_size;
     temp_size = oc_storage_read("g{{my_path|variablesyntax}}{{var|variablesyntax}}", (uint8_t*)&temp{{var|variablesyntax}}, sizeof(temp{{var|variablesyntax}}));
      oc_rep_set_boolean(root, {{var}}, temp{{var|variablesyntax}});
      PRINT("   (startup) %s : %s (%ld)\n", g{{my_path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}, (char *)btoa(temp{{var|variablesyntax}}), temp_size);
    }
    {%- elif var_data.type == "integer" %}
    /* property (integer) '{{var}}' */
    {
      int temp{{var|variablesyntax}};
      long temp_size;
      temp_size = oc_storage_read("g{{my_path|variablesyntax}}{{var|variablesyntax}}", (uint8_t*)&temp{{var|variablesyntax}}, sizeof(temp{{var|variablesyntax}}));
      oc_rep_set_int(root, {{var}}, temp{{var|variablesyntax}});
      PRINT("   (startup) %s : %d (%ld)\n", g{{my_path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}, temp{{var|variablesyntax}}, temp_size);
    }
    {%- elif var_data.type == "number" %}
    /* property (number) '{{var}}' */
    {
      double temp{{var|variablesyntax}};
      long temp_size;
      temp_size = oc_storage_read("g{{my_path|variablesyntax}}{{var|variablesyntax}}", (uint8_t*)&temp{{var|variablesyntax}}, sizeof(temp{{var|variablesyntax}}));
      oc_rep_set_double(root, {{var}}, temp{{var|variablesyntax}});
      PRINT("   (startup) %s : %f (%ld)\n", g{{my_path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}, temp{{var|variablesyntax}}, temp_size);
    }
    {%- elif var_data.type == "string" %}
    /* property (string) '{{var}}' */
    {
      char temp{{var|variablesyntax}}[MAX_STRING];
      long temp_size;
      temp_size = oc_storage_read("g{{my_path|variablesyntax}}{{var|variablesyntax}}", (uint8_t*)&temp{{var|variablesyntax}}, MAX_STRING);
      oc_rep_set_text_string(root, {{var}}, g{{my_path|variablesyntax}}{{var|variablesyntax}});
      PRINT("   (startup) %s : %s (%ld)\n", g{{my_path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}, g{{my_path|variablesyntax}}{{var|variablesyntax}}, temp_size);
    }
    {%- endif %}
 {%- endfor %}
{%- endmacro %}

{%- macro write_props_to_storage(my_data, my_path) -%}
      oc_rep_t *rep = request->request_payload;
      while (rep != NULL) {
        PRINT("key: (assign startup) %s \n", oc_string(rep->name));
        /* no error: assign the variables */
        {% for var, var_data in query_properties_filtered_post(my_data, my_path).items() -%}
        {%- if var_data.type == "boolean" %}
        if (strcmp ( oc_string(rep->name), g{{my_path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}})== 0) {
          /* write storage "{{var}}" */
          long temp_size;
          temp_size = oc_storage_write("g{{my_path|variablesyntax}}{{var|variablesyntax}}", (uint8_t*)&rep->value.boolean, sizeof(g{{my_path|variablesyntax}}{{var|variablesyntax}}));
          PRINT ("  storage (startup.revert)  property '{{var}}' : %s (%ld)\n", (char *)btoa(rep->value.boolean), temp_size);
        }
        {%- elif var_data.type == "integer" %}
        if (strcmp ( oc_string(rep->name), g{{my_path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}) == 0) {
          /* write storage "{{var}}" */
          PRINT ("  storage (startup.revert) property '{{var}}' : %d\n", (int) rep->value.integer);
          oc_storage_write("g{{my_path|variablesyntax}}{{var|variablesyntax}}", (uint8_t*)&rep->value.integer, sizeof(g{{my_path|variablesyntax}}{{var|variablesyntax}}));
        }
        {%- elif var_data.type == "number" %}
        if (strcmp ( oc_string(rep->name), g{{my_path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}) == 0) {
          /* write storage "{{var}}" */
          PRINT ("  storage (startup.revert) property '{{var}}' : %f\n", rep->value.double_p);
          oc_storage_write("g{{my_path|variablesyntax}}{{var|variablesyntax}}", (uint8_t*)&rep->value.double_p, sizeof(g{{my_path|variablesyntax}}{{var|variablesyntax}}));
        }
        {%- elif var_data.type == "string" %}
        if (strcmp ( oc_string(rep->name), g{{my_path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}) == 0) {
          /* write storage "{{var}}" */
          PRINT ("  storage (startup.revert) property '{{var}}' : %s\n", oc_string(rep->value.string));
          oc_storage_write("g{{my_path|variablesyntax}}{{var|variablesyntax}}", (uint8_t*)oc_string(rep->value.string), strlen(oc_string(rep->value.string))+1);
        }
        {%- endif %}
        {%- endfor %}
        rep = rep->next;
    }
{%- endmacro %}


{% for path, path_data in json_data['paths'].items() if "?" not in path %}
/* global property variables for path: "{{path}}" */
{%- if query_if_exist(json_data, path, "oic.if.startup") or query_if_exist(json_data, path, "oic.if.startup.revert") %}
int g{{path|variablesyntax}}_storage_status = 0;  /**< 0=no storage, 1=startup, 2=startup.revert */ 
{%- endif %}
{%- for var, var_data in query_properties_filtered(json_data, path).items() %}
STATIC char *g{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}} = "{{var}}"; /**< the name for the attribute */
{%- if var_data.type == "boolean" %}
{{var_data.type|convert_to_c_type}} g{{path|variablesyntax}}{{var|variablesyntax}} = {{swagger_property_data_schema(json_data, path, var)|init_value_if_empty(var_data.type)}}; /**< current value of property "{{var}}" {{var_data["description"]}} */
{%- elif var_data.type == "integer" %}
{{var_data.type|convert_to_c_type}} g{{path|variablesyntax}}{{var|variablesyntax}} = {{swagger_property_data_schema(json_data, path, var)|init_value_if_empty(var_data.type)}}; /**< current value of property "{{var}}" {{var_data["description"]}} */
{%- elif var_data.type == "number" %}
{{var_data.type|convert_to_c_type}} g{{path|variablesyntax}}{{var|variablesyntax}} = {{swagger_property_data_schema(json_data, path, var)|init_value_if_empty(var_data.type)}}; /**< current value of property "{{var}}"  {{var_data["description"]}} */
{%- elif var_data.type == "string" %}
char g{{path|variablesyntax}}{{var|variablesyntax}}[ {{var_data.maxLength|default("MAX_PAYLOAD_STRING")}} ] = "{{swagger_property_data_schema(json_data, path, var)|init_value_if_empty(var_data.type) }}"; /**< current value of property "{{var}}" {{var_data["description"]}} */
{%- elif var_data.type == "object" %}
/* Object "{{var}}" as structure */
{%- set my_data = var_data.properties |get_c_data() %}
struct {{path|variablesyntax}}{{var|variablesyntax}}_t
{
{%- for k,v in my_data.items() %}
  {{v[0]|convert_to_c_type_no_pointer()}} {{k}} {% if v[0] | convert_to_c_type_array_size() == 1 %}[MAX_PAYLOAD_STRING]{% endif %}{% if v[0] | convert_to_c_type_array_size() == 2 %}[MAX_ARRAY][MAX_PAYLOAD_STRING]{% endif -%};  /**< {{v[1]}} */
  {% if v[0] | convert_to_c_type_array_size() == 2 %}int {{k}}_array_size; /* current size of the array */{% endif %}
{%- endfor %}
};
struct {{path|variablesyntax}}{{var|variablesyntax}}_t g{{path|variablesyntax}}{{var|variablesyntax}};
{%- elif var_data.type == "array" %}
{# start code to generate array contens #}
/* array {{var}}  {{var_data["description"]}} */
{%- if var_data |convert_to_cplus_array_type == "std::vector<bool>" %} 
bool g{{path|variablesyntax}}{{var|variablesyntax}}[{{var_data.maxItems|default("MAX_ARRAY")}}]; 
size_t g{{path|variablesyntax}}{{var|variablesyntax}}_array_size;
{%- elif var_data |convert_to_cplus_array_type == "std::vector<int>" %}
 {%- if is_boolean_array(var_data) == true %}
uint8_t g{{path|variablesyntax}}{{var|variablesyntax}}[{{var_data.maxItems|default("MAX_ARRAY")}}]; 
 {%- else %}
int g{{path|variablesyntax}}{{var|variablesyntax}}[{{var_data.maxItems|default("MAX_ARRAY")}}]; 
 {%- endif %}
size_t g{{path|variablesyntax}}{{var|variablesyntax}}_array_size;

  {%- elif var_data |convert_to_cplus_array_type == "std::vector<double>" %}
double g{{path|variablesyntax}}{{var|variablesyntax}}[{{var_data.maxItems|default("MAX_ARRAY")}}]; 
size_t g{{path|variablesyntax}}{{var|variablesyntax}}_array_size;
  {%- elif var_data |convert_to_cplus_array_type == "std::vector<std::string>" %} 
char g{{path|variablesyntax}}{{var|variablesyntax}}[{{var_data.maxItems|default("MAX_ARRAY")}}][{{var_data.maxLength|default("MAX_PAYLOAD_STRING")}}];
size_t g{{path|variablesyntax}}{{var|variablesyntax}}_array_size;
{%- elif var_data |convert_to_cplus_array_type == "std::vector<OCRepresentation>" -%}
/** array of objects */
{%- set my_data = var_data |get_c_data() %}
struct {{path|variablesyntax}}{{var|variablesyntax}}_t
{
{%- for k,v in my_data.items() %}
  {{v[0]|convert_to_c_type_no_pointer()}} {{k}} {% if v[0] | convert_to_c_type_array_size() == 1 %}[MAX_PAYLOAD_STRING]{% endif %}{% if v[0] | convert_to_c_type_array_size() == 2 %}[MAX_ARRAY][MAX_PAYLOAD_STRING]{% endif -%};  /**< {{v[1]}} */
  {% if v[0] | convert_to_c_type_array_size() == 2 %}int {{k}}_array_size; /**< current size of the array */{% endif %}
{%- endfor %}
};
struct {{path|variablesyntax}}{{var|variablesyntax}}_t g{{path|variablesyntax}}{{var|variablesyntax}}[MAX_ARRAY];
int g{{path|variablesyntax}}{{var|variablesyntax}}_array_size = 0;
{% endif -%}
{# end code of of generating array code #}
{% else %}
/* {{var}} not handled */
{% endif -%}
{% endfor -%}
{% endfor -%}
/** registration data variables for the resources */
{% for path, path_data in json_data['paths'].items() if "?" not in path %}
/* global resource variables for path: {{path}} */
STATIC char *g{{path|variablesyntax}}_RESOURCE_ENDPOINT = "{{path}}"; /**< used path for this resource */
STATIC char *g{{path|variablesyntax}}_RESOURCE_TYPE[MAX_STRING] = {{query_rt(json_data, path)|convert_to_c_type_array}}; /**< rt value (as an array) */
int g{{path|variablesyntax}}_nr_resource_types = {{query_rt(json_data, path)|convert_array_size}}; /**< number of resource type entries */
{%- endfor %}

/**
 * function to set up the device.
 * 
 * sets the:
 * - OCF device_type
 * - friendly device name
 * - OCF version
 * - introspection device data
 *
*/
int
app_init(void)
{
  int ret = oc_init_platform("{{manufacturer}}", NULL, NULL);
  /* the settings determine the appearance of the device on the network
     can be ocf.2.2.0 (or even higher)
     supplied values are for ocf.2.2.3 */
  ret |= oc_add_device("/oic/d", "{{device_type}}", "{{json_data['info']['title']}}", 
                       "ocf.2.2.3", /* icv value */
                       "ocf.res.1.3.0, ocf.sh.1.3.0",  /* dmv value */
                       NULL, NULL);
                       
#if defined(OC_IDD_API)
  FILE *fp;
  uint8_t *buffer;
  size_t buffer_size;
  const char introspection_error[] =
    "\tERROR Could not read 'server_introspection.cbor'\n"
    "\tIntrospection data not set.\n";
  fp = fopen("./server_introspection.cbor", "rb");
  if (fp) {
    fseek(fp, 0, SEEK_END);
    buffer_size = ftell(fp);
    rewind(fp);

    buffer = (uint8_t *)malloc(buffer_size * sizeof(uint8_t));
    size_t fread_ret = fread(buffer, buffer_size, 1, fp);
    fclose(fp);

    if (fread_ret == 1) {
      oc_set_introspection_data(0, buffer, buffer_size);
      PRINT("\tIntrospection data set 'server_introspection.cbor': %d [bytes]\n", (int)buffer_size);
    } else {
      PRINT("%s", introspection_error);
    }
    free(buffer);
  } else {
    PRINT("%s", introspection_error);
  }
#else
    PRINT("\t introspection via header file\n");
#endif
  return ret;
}

/**
 * helper function to check if the POST input document contains 
 * the common readOnly properties or the resouce readOnly properties
 * @param name the name of the property
 * @param error_state the current (input) error state
 * @return the error_status, e.g. if error_status is true, then the input document contains something illegal
 */
bool
check_on_readonly_common_resource_properties(oc_string_t name, bool error_state)
{
  if (strcmp ( oc_string(name), "n") == 0) {
    error_state = true;
    PRINT ("   property \"n\" is ReadOnly \n");
  }else if (strcmp ( oc_string(name), "if") == 0) {
    error_state = true;
    PRINT ("   property \"if\" is ReadOnly \n");
  } else if (strcmp ( oc_string(name), "rt") == 0) {
    error_state = true;
    PRINT ("   property \"rt\" is ReadOnly \n");
  } else if (strcmp ( oc_string(name), "id") == 0) {
    error_state = true;
    PRINT ("   property \"id\" is ReadOnly \n");
  } else if (strcmp ( oc_string(name), "id") == 0) {
    error_state = true;
    PRINT ("   property \"id\" is ReadOnly \n");
  } 
  return error_state;
}

{% for path, path_data in json_data['paths'].items() if "?" not in path -%}
{% for methodName, method_data in path_data.items() -%}
{% if methodName == "get" %} 
/**
 * get method for "{{path}}" resource.
 * function is called to intialize the return values of the GET method.
 * initialisation of the returned values are done from the global property values.
 * Resource Description:
{{method_data.description| code_indent(" * ")}}
 *
 * @param request the request representation.
 * @param interfaces the interface used for this call
 * @param user_data the user data.
*/
STATIC void
get{{path|variablesyntax}}(oc_request_t *request, oc_interface_mask_t interfaces, void *user_data)
{
  (void)user_data;  /* variable not used */
  /* TODO: SENSOR add here the code to talk to the HW if one implements a sensor.
     the call to the HW needs to fill in the global variable before it returns to this function here.
     alternative is to have a callback from the hardware that sets the global variables.
  */
  bool error_state = false; /**< the error state, the generated code */
  int oc_status_code = OC_STATUS_OK;
  {% set query_list = list_query_params(json_data, path)  %}
  {%- for item in query_list %}
  /* query name '{{item.name}}' type: '{{item.type}}', enum: {{item.enum}}*/
  char *{{item.name|variablesyntax}} = NULL; /* not null terminated {{item.description}} */
  int {{item.name|variablesyntax}}_len = oc_get_query_value(request, "{{item.name}}", &{{item.name|variablesyntax}});
  if ({{item.name|variablesyntax}}_len != -1) {
    PRINT (" query value '{{item.name}}': %.*s\n", {{item.name|variablesyntax}}_len, {{item.name|variablesyntax}});
    bool query_ok = false;
    /* input check {{item.enum}} {{item.pattern}} */
  {% for enum_value in item.enum %}
    if ( strncmp ({{item.name|variablesyntax}}, "{{enum_value}}", {{item.name|variablesyntax}}_len) == 0)  query_ok = true;
  {%- endfor %}
    if (query_ok == false) error_state = true;
    /* TODO: use the query value to tailer the response*/
  }
  {%- endfor %}
  
  PRINT("-- Begin get{{path|variablesyntax}}: interface %d\n", interfaces);
  oc_rep_start_root_object();
  switch (interfaces) {
  case OC_IF_BASELINE:
    PRINT("   Adding Baseline info\n" );
    oc_process_baseline_interface(request->resource);
    {%- if query_if_exist(json_data, path, "oic.if.w") == false %}
    {{ get_args(json_data, path) }}
    {%- endif %}
    break;
  {%- if query_if_exist(json_data, path, "oic.if.a") %}
  case OC_IF_A:
    {{ get_args(json_data, path) }}
    break;
  {%- endif %}
  {%- if query_if_exist(json_data, path, "oic.if.s") %}
  case OC_IF_S:
    {{ get_args(json_data, path) }}
    break;
  {%- endif %}
  {%- if query_if_exist(json_data, path, "oic.if.r") %}
  case OC_IF_R:
    {{ get_args(json_data, path) }}
    break;
  {%- endif %}
  {%- if query_if_exist(json_data, path, "oic.if.rw") %}
  case OC_IF_RW:
   {{ get_args(json_data, path) }}
    break;
  {% endif -%}
  {%- if query_if_exist(json_data, path, "oic.if.w") %}
  case OC_IF_W:
    error_state = true;
    break;
  {% endif -%}
  {%- if query_if_exist(json_data, path, "oic.if.startup") %}
  case OC_IF_STARTUP:
   if ( g{{path|variablesyntax}}_storage_status !=  1)
   {
     error_state = true;
     break;
   } 
   {{ get_start_args(json_data, path) }}
    break;
  {%- endif %}
  {%- if query_if_exist(json_data, path, "oic.if.startup.revert") %}
  case OC_IF_STARTUP_REVERT:
   if ( g{{path|variablesyntax}}_storage_status !=  2)
   {
     error_state = true;
     break;
   } 
   oc_status_code = OC_STATUS_NOT_MODIFIED;
   {{ get_start_args(json_data, path) }}
    break;
  {%- endif %}
  default:
    break;
  }
  oc_rep_end_root_object();
  if (error_state == false) {
    oc_send_response(request, oc_status_code);
  }
  else {
    oc_send_response(request, OC_STATUS_BAD_OPTION);
  }
  PRINT("-- End get{{path|variablesyntax}}\n");
}
{% endif -%}
{% endfor -%}
{% endfor -%}

{% for path, path_data in json_data['paths'].items() if "?" not in path  -%}
{% for methodName, method_data in path_data.items() -%}
{% if methodName == "post" %} 
/**
 * post method for "{{path}}" resource.
 * The function has as input the request body, which are the input values of the POST method.
 * The input values (as a set) are checked if all supplied values are correct.
 * If the input values are correct, they will be assigned to the global  property values.
 * Resource Description:
{{method_data.description | code_indent(" * ")}}
 *
 * @param request the request representation.
 * @param interfaces the used interfaces during the request.
 * @param user_data the supplied user data.
 */
STATIC void
post{{path|variablesyntax}}(oc_request_t *request, oc_interface_mask_t interfaces, void *user_data)
{
  (void)interfaces;
  (void)user_data;
  bool error_state = false;
  PRINT("-- Begin post{{path|variablesyntax}}:\n");
  oc_rep_t *rep = request->request_payload;
  {% set query_list = list_query_params_post(json_data, path)  %}
  {%- for item in query_list %}
  /* query name '{{item.name}}' type: '{{item.type}}', enum: {{item.enum}}*/
  char *{{item.name|variablesyntax}} = NULL; /* not null terminated {{item.description}} */
  int {{item.name|variablesyntax}}_len = oc_get_query_value(request, "{{item.name}}", &{{item.name|variablesyntax}});
  if ({{item.name|variablesyntax}}_len != -1) {
    bool query_ok = false;
  {% for enum_value in item.enum %}
    if ( strncmp ({{item.name|variablesyntax}}, "{{enum_value}}", {{item.name|variablesyntax}}_len) == 0)  query_ok = true;
  {%- endfor %}
    if (query_ok == false) error_state = true;
    PRINT (" query value '{{item.name}}': %.*s\n", {{item.name|variablesyntax}}_len, {{item.name|variablesyntax}});
    /* TODO: use the query value to tailer the response*/
  }
  {%- endfor %}
  /* loop over the request document for each required input field to check if all required input fields are present */
  {%- if query_required_items(json_data, path) %}
  {%- for required_var in query_required_items(json_data, path) %}
  {% if loop.first %}bool var_in_request= false; {% else %}var_in_request= false; {% endif %}
  rep = request->request_payload;
  while (rep != NULL) {
    if (strcmp ( oc_string(rep->name), g{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{required_var|variablesyntax}}) == 0) {
      var_in_request = true;
    }
    rep = rep->next;
  }
  if ( var_in_request == false) 
  { 
    error_state = true;
    PRINT (" required property: '{{required_var}}' not in request\n");
  }
  {%- endfor %}
  {%- endif %}
  /* loop over the request document to check if all inputs are ok */
  rep = request->request_payload;
  while (rep != NULL) {
    PRINT("key: (check) %s \n", oc_string(rep->name));
    {# common & resource properties that are readOnly "n", "if", "rt", "id", "range", "step", "precision" #}
    error_state = check_on_readonly_common_resource_properties(rep->name, error_state);
    {%- for var, var_data in query_properties_filtered_post(json_data, path).items() -%}
    {%- if var_data.type == "boolean" %}
    if (strcmp ( oc_string(rep->name), g{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}) == 0) {
      /* property "{{var}}" of type boolean exist in payload */
      {%- if var_data.readOnly -%}
      {% if var_data.readOnly == true %}/* check if "{{var}}" is read only */
      error_state = true;
      PRINT ("   property '{{var}}' is readOnly \n");
      {%- endif -%}{% endif %}
      if (rep->type != OC_REP_BOOL) {
        error_state = true;
        PRINT ("   property '{{var}}' is not of type bool %d \n", rep->type);
      }
    }
    {%- elif var_data.type == "integer" %}
    if (strcmp ( oc_string(rep->name), g{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}) == 0) {
      /* property "{{var}}" of type integer exist in payload */
      {%- if var_data.readOnly -%}
      {% if var_data.readOnly == true %}/* check if "{{var}}" is read only */
      error_state = true;
      PRINT ("   property '{{var}}' is readOnly \n");
      {%- endif -%}{% endif %}
      if (rep->type != OC_REP_INT) {
        error_state = true;
        PRINT ("   property '{{var}}' is not of type int %d \n", rep->type);
      }
      {% if var_data.minimum %}int value_min = (int) rep->value.integer;
      if ( value_min < {{var_data.minimum}} ) {
        /* check the minimum range */
        PRINT ("   property '{{var}}' value smaller than minimum : {{var_data.minimum}} <  value: %d \n", value_min);
        error_state = true;
      }{% endif %}
      {% if var_data.maximum %}int value_max = (int) rep->value.integer;
      if ( value_max > {{var_data.maximum}} ) {
        /* check the maximum range */
        PRINT ("   property '{{var}}' value exceed max : {{var_data.minimum}} >  value: %d \n", value_max);
        error_state = true;
      }{% endif %}
    } 
    {%- elif var_data.type == "number" %}
    if (strcmp ( oc_string(rep->name), g{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}) == 0) {
      /* property "{{var}}" of type double exist in payload */
      {%- if var_data.readOnly %}
      {% if var_data.readOnly == true %}/* check if "{{var}}" is read only */
      error_state = true;
      PRINT ("   property '{{var}}' is readOnly \n");
      {%- endif -%}{% endif %} 
      if ( (rep->type != OC_REP_DOUBLE) & (rep->type != OC_REP_INT)) {
        error_state = true;
        PRINT ("   property '{{var}}' is not of type double or int %d \n", rep->type);
      }
      {%- if var_data.minimum %}
      double value_min_check = 0;
      if (rep->type == OC_REP_DOUBLE)
        value_min_check = rep->value.double_p;
      if (rep->type == OC_REP_INT)
        value_min_check = (double) rep->value.integer;
      if ( value_min_check < {{var_data.minimum}} ) {
        /* check the minimum range */
        PRINT ("   property '{{var}}' value smaller than minimum : {{var_data.minimum}} <  value: %f \n", value_min_check);
        error_state = true;
      }{% endif -%}
      {% if var_data.maximum %}
      double value_max_check = 0;
      if (rep->type == OC_REP_DOUBLE)
        value_max_check = rep->value.double_p;
      if (rep->type == OC_REP_INT)
        value_max_check = (double) rep->value.integer;
      if ( value_max_check > {{var_data.maximum}} ) {
        /* check the maximum range */
        PRINT ("   property '{{var}}' value exceed max : {{var_data.minimum}} >  value: %f \n", value_max_check);
        error_state = true;
      }{%- endif %}
    }
    {%- elif var_data.type == "string" %}
    if (strcmp ( oc_string(rep->name), g{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}) == 0) {
      /* property "{{var}}" of type string exist in payload */
      {%- if var_data.readOnly -%}
      {% if var_data.readOnly == true %}/* check if "{{var}}" is read only */
      error_state = true;
      PRINT ("   property '{{var}}' is readOnly \n");
      {% endif -%}{% endif %}
      if (rep->type != OC_REP_STRING) {
        error_state = true;
        PRINT ("   property '{{var}}' is not of type string %d \n", rep->type);
      }
      if (strlen(oc_string(rep->value.string)) >=  ({{var_data.maxLength|default("MAX_PAYLOAD_STRING")}}-1) )
      {
        error_state = true;
        PRINT ("   property '{{var}}' is too long %d expected: {{var_data.maxLength|default("MAX_PAYLOAD_STRING")}}-1 \n", (int)strlen(oc_string(rep->value.string)));
      }
    }
    {%- elif var_data.type == "array" %}
    if (strcmp ( oc_string(rep->name), g{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}) == 0) {
      /* property "{{var}}" of type array exist in payload */
      {% if var_data.readOnly -%}
      {% if var_data.readOnly == true %}/* check if "{{var}}" is read only */
      error_state = true;
      PRINT ("   property '{{var}}' is readOnly \n");
      {%- endif -%}{% endif %}
      size_t array_size=0;
      {% if var_data |convert_to_cplus_array_type == "std::vector<bool>" %}
      bool *temp_array = 0;  
      oc_rep_get_bool_array(rep, "{{var}}", &temp_array, &array_size);
      {%- elif var_data |convert_to_cplus_array_type == "std::vector<int>" %}
      if (rep->type == OC_REP_BYTE_STRING)
      {
        char *temp_byte_array = 0;  
        oc_rep_get_byte_string(rep, "{{var}}", &temp_byte_array, &array_size);
      }
      else {
        int64_t *temp_array = 0;  
        oc_rep_get_int_array(rep, "{{var}}", &temp_array, &array_size);
      }  
      {%- elif var_data |convert_to_cplus_array_type == "std::vector<double>" %}
      double *temp_array = 0;  
      oc_rep_get_double_array(rep, "{{var}}", &temp_array, &array_size);
      {% elif var_data |convert_to_cplus_array_type == "std::vector<string>" %}
      array_size = oc_string_array_get_allocated_size(rep->value.array)
      {% endif %}
      if ( array_size > {{var_data.maxItems|default("MAX_ARRAY")}})
      {
         error_state = true;
         PRINT ("   property array '{{var}}' is too long: %d expected: {{var_data.maxItems|default("MAX_ARRAY")}} \n", (int)array_size);
      }
    } 
    {%- elif var_data.type == "object" %}
    if (strcmp ( oc_string(rep->name), g{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}) == 0) {
      /* property "{{var}}" of type object exist in payload */
      if (rep->type != OC_REP_OBJECT) {
        error_state = true;
        PRINT ("   property '{{var}}' is not of type object %d \n", rep->type);
      }
      {% if var_data.readOnly -%}
      {% if var_data.readOnly == true %}/* check if "{{var}}" is read only */
      error_state = true;
      PRINT ("   property '{{var}}' is readOnly \n");
      {% endif -%}{% endif -%}
    } {%- endif %}
    {%- endfor -%}
    rep = rep->next;
  }
  /* if the input is ok, then process the input document and assign the global variables */
  if (error_state == false)
  {
    switch (interfaces) {
{%- if query_if_exist(json_data, path, "oic.if.startup") %}
    case OC_IF_STARTUP: {
      g{{path|variablesyntax}}_storage_status = 1;
      oc_storage_write("g{{path|variablesyntax}}_storage_status", (uint8_t*)&g{{path|variablesyntax}}_storage_status, sizeof(g{{path|variablesyntax}}_storage_status));
      /* loop over all the properties in the input document */
      {{write_props_to_storage(json_data, path)}}
      /* set the response */
      PRINT("Set response (startup) \n");
      oc_rep_start_root_object();
      {{ get_start_args(json_data, path) }}
      oc_rep_end_root_object();
      oc_send_response(request, OC_STATUS_CHANGED);
      }
      break;
  {%- endif %}
  {%- if query_if_exist(json_data, path, "oic.if.startup.revert") %}
  case OC_IF_STARTUP_REVERT: {
      g{{path|variablesyntax}}_storage_status = 2;
      oc_storage_write("g{{path|variablesyntax}}_storage_status", (uint8_t*)&g{{path|variablesyntax}}_storage_status, sizeof(g{{path|variablesyntax}}_storage_status));
      /* loop over all the properties in the input document */
      {{write_props_to_storage(json_data, path)}}
      /* set the response */
      PRINT("Set response (startup) \n");
      oc_rep_start_root_object();
      {{ get_start_args(json_data, path) }}
      oc_rep_end_root_object();
      oc_send_response(request, OC_STATUS_CHANGED);
      }
      break;
  {%- endif %}
    default: {
      {%- if query_if_exist(json_data, path, "oic.if.startup.revert") %}  
      if ( g{{path|variablesyntax}}_storage_status == 2 ) { 
        /* write the properties to the storage */
      {{write_props_to_storage(json_data, path)}}
      } /* g{{path|variablesyntax}}_storage_status */
      {%- endif %}
      /* loop over all the properties in the input document */
      oc_rep_t *rep = request->request_payload;
      while (rep != NULL) {
        PRINT("key: (assign) %s \n", oc_string(rep->name));
        /* no error: assign the variables */
        {% for var, var_data in query_properties_filtered_post(json_data, path).items() -%}
        {%- if var_data.type == "boolean" %}
        if (strcmp ( oc_string(rep->name), g{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}})== 0) {
          /* assign "{{var}}" */
          PRINT ("  property '{{var}}' : %s\n", (char *)btoa(rep->value.boolean));
          g{{path|variablesyntax}}{{var|variablesyntax}} = rep->value.boolean;
        }
        {%- elif var_data.type == "integer" %}
        if (strcmp ( oc_string(rep->name), g{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}) == 0) {
          /* assign "{{var}}" */
          PRINT ("  property '{{var}}' : %d\n", (int) rep->value.integer);
          g{{path|variablesyntax}}{{var|variablesyntax}} = (int) rep->value.integer;
        }
        {%- elif var_data.type == "number" %}
        if (strcmp ( oc_string(rep->name), g{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}) == 0) {
          /* assign "{{var}}" */
          PRINT ("  property '{{var}}' : %f\n", rep->value.double_p);
          g{{path|variablesyntax}}{{var|variablesyntax}} = rep->value.double_p;
        }
        {%- elif var_data.type == "string" %}
        if (strcmp ( oc_string(rep->name), g{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}) == 0) {
          /* assign "{{var}}" */
          PRINT ("  property '{{var}}' : %s\n", oc_string(rep->value.string));
          strncpy(g{{path|variablesyntax}}{{var|variablesyntax}}, oc_string(rep->value.string), {{var_data.maxLength|default("MAX_PAYLOAD_STRING")}}-1);
        }
        {%- elif var_data.type == "array" -%}
          {# array types #}
          {%- if var_data |convert_to_cplus_array_type == "std::vector<bool>" %} {# array of booleans #}
          if (strcmp ( oc_string(rep->name), g{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}) == 0) {
            /* retrieve the array pointer to the boolean array of of property "{{var}}"
               note that the variable g{{path|variablesyntax}}{{var|variablesyntax}}_array_size will contain the array size in the payload. */
            bool *temp_bool = 0;
            oc_rep_get_bool_array(rep, "{{var}}", &temp_bool, &g{{path|variablesyntax}}{{var|variablesyntax}}_array_size);
            /* copy over the data of the retrieved array to the global variable */
            for (int j = 0; j < (int)g{{path|variablesyntax}}{{var|variablesyntax}}_array_size; j++) {
              PRINT(" bool %d ", temp_bool[j]);
              g{{path|variablesyntax}}{{var|variablesyntax}}[j] = temp_bool[j];
            }
          }
          {%- elif var_data |convert_to_cplus_array_type == "std::vector<int>" %} {# array of integers #}
          if (strcmp ( oc_string(rep->name), g{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}) == 0) {
              /* retrieve the array pointer to the int array of of property "{{var}}"
                 note that the variable g{{path|variablesyntax}}{{var|variablesyntax}}_array_size will contain the array size in the payload. */
             if (rep->type == OC_REP_BYTE_STRING) {
               char *temp_array = 0;  
               oc_rep_get_byte_string(rep, "{{var}}", &temp_array, &g{{path|variablesyntax}}{{var|variablesyntax}}_array_size);
               /* copy over the data of the retrieved (byte) array to the global variable */
               for (int j = 0; j < (int)g{{path|variablesyntax}}{{var|variablesyntax}}_array_size; j++) {
                 PRINT(" byte %d ", temp_array[j]);
                 g{{path|variablesyntax}}{{var|variablesyntax}}[j] = temp_array[j];
               }
             }
             else {
               int64_t *temp_integer = 0;
               oc_rep_get_int_array(rep, "{{var}}", &temp_integer, &g{{path|variablesyntax}}{{var|variablesyntax}}_array_size);
               /* copy over the data of the retrieved (integer) array to the global variable */
               for (int j = 0; j < (int)g{{path|variablesyntax}}{{var|variablesyntax}}_array_size; j++) {
                 PRINT(" integer %lld ", temp_integer[j]);
                 {%- if is_boolean_array(var_data) == true %}
                 g{{path|variablesyntax}}{{var|variablesyntax}}[j] = (uint8_t)temp_integer[j];
                 {%- else %}
                 g{{path|variablesyntax}}{{var|variablesyntax}}[j] = temp_integer[j];
                 {%- endif %}
               }
             }
          }
          {%- elif var_data |convert_to_cplus_array_type == "std::vector<double>" %} {# array of numbers #}
          if (strcmp ( oc_string(rep->name), g{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}) == 0) {
              /* retrieve the array pointer to the double array of property "{{var}}"
                 note that the variable g{{path|variablesyntax}}{{var|variablesyntax}}_array_size will contain the array size in the payload. */
              double *temp_double = 0;
              oc_rep_get_double_array(rep, "{{var}}", &temp_double, &g{{path|variablesyntax}}{{var|variablesyntax}}_array_size);
              /* copy over the data of the retrieved array to the global variable */
              for (int j = 0; j < (int)g{{path|variablesyntax}}{{var|variablesyntax}}_array_size; j++) {
                PRINT(" double %f ", temp_double[j]);
                g{{path|variablesyntax}}{{var|variablesyntax}}[j] = temp_double[j];
              }
          }
          {%- elif var_data |convert_to_cplus_array_type == "std::vector<std::string>" %} {# array of strings #}
          if (strcmp ( oc_string(rep->name), g{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}) == 0) {
              for (int j = 0; j < (int)oc_string_array_get_allocated_size(rep->value.array); j++) {
                PRINT(" string %s ", oc_string_array_get_item(rep->value.array, j));
                strncpy(g{{path|variablesyntax}}{{var|variablesyntax}}[j], oc_string_array_get_item(rep->value.array, j), MAX_STRING-1);
              }
              /* set the received array size in the global variable */
              g{{path|variablesyntax}}{{var|variablesyntax}}_array_size = (size_t)oc_string_array_get_allocated_size(rep->value.array);
          }
          {%- else %}  
          /* array type not handled {{var}} */
          {%- endif %}
        {%- elif var_data.type == "object" %}
        /* TODO: OBJECT NOT HANDLED "{{var}}" */
        {%- else %}
        /* property not handled: "{{var}}" */
        {% endif -%}
        {%- endfor %}
        rep = rep->next;
      }
      /* set the response */
      PRINT("Set response \n");
      oc_rep_start_root_object();
      /*oc_process_baseline_interface(request->resource); */
      {%- for var, var_data in query_properties_filtered(json_data, path).items() %}
      {%- if var_data.type == "boolean" %}
      PRINT("   %s : %s", g{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}, (char *)btoa(g{{path|variablesyntax}}{{var|variablesyntax}}));
      oc_rep_set_boolean(root, {{var}}, g{{path|variablesyntax}}{{var|variablesyntax}}); 
      {%- if query_if_exist(json_data, path, "oic.if.startup.revert") %}
      oc_storage_write("g{{path|variablesyntax}}{{var|variablesyntax}}", (uint8_t*)&g{{path|variablesyntax}}{{var|variablesyntax}}, sizeof(g{{path|variablesyntax}}{{var|variablesyntax}}));
      {%- endif %}
      {%- elif var_data.type == "number" %}
      PRINT("   %s : %f\n", g{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}, g{{path|variablesyntax}}{{var|variablesyntax}});
      oc_rep_set_double(root, {{var}}, g{{path|variablesyntax}}{{var|variablesyntax}} ); 
      {%- if query_if_exist(json_data, path, "oic.if.startup.revert") %}
      oc_storage_write("g{{path|variablesyntax}}{{var|variablesyntax}}", (uint8_t*)&g{{path|variablesyntax}}{{var|variablesyntax}}, sizeof(g{{path|variablesyntax}}{{var|variablesyntax}}));
      {%- endif %}
      {%- elif var_data.type == "integer" %}
      PRINT("   %s : %d\n", g{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}, g{{path|variablesyntax}}{{var|variablesyntax}});
      oc_rep_set_int(root, {{var}}, g{{path|variablesyntax}}{{var|variablesyntax}} );
      {%- if query_if_exist(json_data, path, "oic.if.startup.revert") %}
      oc_storage_write("g{{path|variablesyntax}}{{var|variablesyntax}}", (uint8_t*)&g{{path|variablesyntax}}{{var|variablesyntax}}, sizeof(g{{path|variablesyntax}}{{var|variablesyntax}}));
      {%- endif %}
      {%- elif var_data.type == "string" %}
      PRINT("   %s : %s\n", g{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}, g{{path|variablesyntax}}{{var|variablesyntax}});
      oc_rep_set_text_string(root, {{var}}, g{{path|variablesyntax}}{{var|variablesyntax}}); 
      {%- if query_if_exist(json_data, path, "oic.if.startup.revert") %}
      oc_storage_write("g{{path|variablesyntax}}{{var|variablesyntax}}", (uint8_t*)&g{{path|variablesyntax}}{{var|variablesyntax}}, sizeof(g{{path|variablesyntax}}{{var|variablesyntax}}));
      {%- endif %}
      {%- elif var_data.type == "array" %}
      {% if var_data |convert_to_cplus_array_type == "std::vector<bool>" %} {# array of booleans #}
      oc_rep_set_array(root, {{var}});
      for (int i=0; i< (int)g{{path|variablesyntax}}{{var|variablesyntax}}_array_size; i++) {
        oc_rep_add_boolean({{var}}, g{{path|variablesyntax}}{{var|variablesyntax}}[i]);
      }
      oc_rep_close_array(root, {{var}});
      {% elif var_data |convert_to_cplus_array_type == "std::vector<int>" %} {# array of integers #}
      oc_rep_set_array(root, {{var}});
      for (int i=0; i< (int)g{{path|variablesyntax}}{{var|variablesyntax}}_array_size; i++) {
        oc_rep_add_int({{var}}, g{{path|variablesyntax}}{{var|variablesyntax}}[i]);
      }
      oc_rep_close_array(root, {{var}});
      {% elif var_data |convert_to_cplus_array_type == "std::vector<double>" %} {# array of doubles/numbers #}
      oc_rep_set_array(root, {{var}});
      for (int i=0; i< (int)g{{path|variablesyntax}}{{var|variablesyntax}}_array_size; i++) {
        oc_rep_add_double({{var}}, g{{path|variablesyntax}}{{var|variablesyntax}}[i]);
      }
      oc_rep_close_array(root, {{var}});
      {% elif var_data |convert_to_cplus_array_type == "std::vector<std::string>" -%}
      oc_rep_set_array(root, {{var}});
      for (int i=0; i< (int)g{{path|variablesyntax}}{{var|variablesyntax}}_array_size; i++) {
        oc_rep_add_text_string({{var}}, g{{path|variablesyntax}}{{var|variablesyntax}}[i]);
      }
      oc_rep_close_array(root, {{var}});
      {% endif -%} {# end of array #}
      {%- elif var_data.type == "object" %}
      /* property (object) "{{var}}" */
      PRINT("   Object : %s\n", g{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}});
      oc_rep_set_object(root, {{var}});
      {%- set my_data = var_data.properties |get_c_data() %}
      {%- for k,v in my_data.items() %}
  {%- if v[0] == "integer" %}
      oc_rep_set_int({{var}}, {{k}}, g{{path|variablesyntax}}{{var|variablesyntax}}.{{k}});
      PRINT("    int {{k}} : %d\n", g{{path|variablesyntax}}{{var|variablesyntax}}.{{k}});
  {%- elif v[0] == "boolean" %}
      oc_rep_set_boolean({{var}}, {{k}}, g{{path|variablesyntax}}{{var|variablesyntax}}.{{k}});
      PRINT("    boolean {{k}} : %s\n", (char *)btoa(g{{path|variablesyntax}}{{var|variablesyntax}}.{{k}}));
  {%- elif v[0] == "number" %}
      oc_rep_set_double({{var}}, {{k}}, g{{path|variablesyntax}}{{var|variablesyntax}}.{{k}});
      PRINT("    number {{k}} : %f\n", g{{path|variablesyntax}}{{var|variablesyntax}}.{{k}});
  {%- elif v[0] == "string" %}
      oc_rep_set_text_string({{var}}, {{k}}, g{{path|variablesyntax}}{{var|variablesyntax}}.{{k}});
      PRINT("    string {{k}} : %s\n", g{{path|variablesyntax}}{{var|variablesyntax}}.{{k}});
  {%- elif v[0] == "string[]" %}
      oc_rep_open_array({{var}}, {{k}});
      PRINT("    array {{k}} \n"); 
      for (int i = 0; i< g{{path|variablesyntax}}{{var|variablesyntax}}.{{k}}_array_size ; i++) {
        oc_rep_add_text_string({{k}}, g{{path|variablesyntax}}{{var|variablesyntax}}.{{k}}[i]);
        PRINT("     array item string {{k}}[0] : %s\n", g{{path|variablesyntax}}{{var|variablesyntax}}.{{k}}[i]);
      }
      oc_rep_close_array({{var}}, {{k}});
  {%- else %}
    /* {{k}} not handled */
  {%- endif %}
  {%- endfor %}  {# loop over k #}
      oc_rep_close_object(root, {{var}});
      {% endif -%}
      {%- endfor %}
    
      oc_rep_end_root_object();
      /* TODO: ACTUATOR add here the code to talk to the HW if one implements an actuator.
       one can use the global variables as input to those calls
       the global values have been updated already with the data from the request */
      oc_send_response(request, OC_STATUS_CHANGED);
      }
    }
  }
  else
  {
    PRINT("  Returning Error \n");
    /* TODO: add error response, if any */
    //oc_send_response(request, OC_STATUS_NOT_MODIFIED);
    oc_send_response(request, OC_STATUS_BAD_REQUEST);
  }
  PRINT("-- End post{{path|variablesyntax}}\n");
}
{% endif -%}
{% endfor -%}
{%- endfor %}  

{% for path, path_data in json_data['paths'].items()  if "?" not in path  -%}
{% for methodName, method_data in path_data.items() -%}
{% if methodName == "delete" %} 
/**
 * delete method for "{{path}}" resource.
 * Resource Description:
{{method_data.description | code_indent(" * ")}}
 *
 * @param request the request representation.
 * @param interfaces the used interfaces during the request.
 * @param user_data the supplied user data.
 */
STATIC void
delete{{path|variablesyntax}}(oc_request_t *request, oc_interface_mask_t interfaces, void *user_data)
{
  (void)request;
  (void)interfaces;
  (void)user_data;
  bool error_state = false;
   {% set query_list = list_query_params_delete(json_data, path)  %}
  {%- for item in query_list %}
  /* query name '{{item.name}}' type: '{{item.type}}'*/
  char *{{item.name|variablesyntax}} = NULL; /* not null terminated {{item.description}} */
  int {{item.name|variablesyntax}}_len = oc_get_query_value(request, "{{item.name}}", &{{item.name|variablesyntax}});
  if ({{item.name|variablesyntax}}_len != -1) {
    bool query_ok = false;
    /* input check {{item.enum}} {{item.pattern}} */
  {% for enum_value in item.enum %}
    if ( strncmp ({{item.name|variablesyntax}}, "{{enum_value}}", {{item.name|variablesyntax}}_len) == 0)  query_ok = true;
  {%- endfor %}
    if (query_ok == false) error_state = true;
    PRINT (" query value '{{item.name}}': %.*s\n", {{item.name|variablesyntax}}_len, {{item.name|variablesyntax}});
    /* TODO: use the query value to tailer the response*/
  }
  {%- endfor %}
  if (error_state == false) {
    oc_send_response(request, OC_STATUS_OK);
  }
  else {
    oc_send_response(request, OC_STATUS_BAD_OPTION);
  }
  PRINT("-- End delete{{path|variablesyntax}}\n");
}
{% endif -%}
{% endfor -%}
{%- endfor %}

/**
 * register all the resources to the stack
 * this function registers all application level resources:
 * - each resource path is bind to a specific function for the supported methods (GET, POST, PUT)
 * - each resource is 
 *   - secure
 *   - observable
 *   - discoverable 
 *   - used interfaces, including the default interface.
 *     default interface is the first of the list of interfaces as specified in the input file
*/
void
register_resources(void)
{
{% for path, path_data in json_data['paths'].items() if "?" not in path %}
  PRINT("Register Resource with local path \"{{path}}\"\n");
  oc_resource_t *res{{path|variablesyntax}} = oc_new_resource(NULL, g{{path|variablesyntax}}_RESOURCE_ENDPOINT, g{{path|variablesyntax}}_nr_resource_types, 0);
  PRINT("     number of Resource Types: %d\n", g{{path|variablesyntax}}_nr_resource_types);
  for( int a = 0; a < g{{path|variablesyntax}}_nr_resource_types; a++ ) {
    PRINT("     Resource Type: \"%s\"\n", g{{path|variablesyntax}}_RESOURCE_TYPE[a]);
    oc_resource_bind_resource_type(res{{path|variablesyntax}},g{{path|variablesyntax}}_RESOURCE_TYPE[a]);
  }
  {{ create_interfaces(json_data, path) }} 
  oc_resource_set_discoverable(res{{path|variablesyntax}}, true);
  /* periodic observable
     to be used when one wants to send an event per time slice
     period is 1 second */
  oc_resource_set_periodic_observable(res{{path|variablesyntax}}, 1);
  /* set observable
     events are send when oc_notify_observers(oc_resource_t *resource) is called.
    this function must be called when the value changes, preferable on an interrupt when something is read from the hardware. */
  /*oc_resource_set_observable(res{{path|variablesyntax}}, true); */
  {% for methodName, method_data in path_data.items() -%}
  {% if methodName == "get" %} 
  oc_resource_set_request_handler(res{{path|variablesyntax}}, OC_GET, get{{path|variablesyntax}}, NULL);
  {% endif -%}
  {% if methodName == "post" %} 
  oc_resource_set_request_handler(res{{path|variablesyntax}}, OC_POST, post{{path|variablesyntax}}, NULL);
  {% endif -%}
  {% if methodName == "put" %} 
  oc_resource_set_request_handler(res{{path|variablesyntax}}, OC_PUT, put{{path|variablesyntax}}, NULL);
  {%- endif %}
  {% if methodName == "delete" %} 
  oc_resource_set_request_handler(res{{path|variablesyntax}}, OC_DELETE, delete{{path|variablesyntax}}, NULL);
  {%- endif %}
#ifdef OC_CLOUD
  oc_cloud_add_resource(res{{path|variablesyntax}});
#endif
{%- endfor %}
  oc_add_resource(res{{path|variablesyntax}});
{%- endfor %}
  /* disable observe for oic/d */
  oc_resource_t* device_resource = oc_core_get_resource_by_index(OCF_D, DEVICE);
  oc_resource_set_observable(device_resource, false);
  /* disable observe for oic/p */
  oc_resource_t* platform_resource = oc_core_get_resource_by_index(OCF_P, DEVICE);
  oc_resource_set_observable(platform_resource, false);
  
#ifdef OPTIMIZE_PSTAT
  /* disable observe on PSTAT resource to save on peak memory consumption */
  oc_resource_t *pstat_resource = oc_core_get_resource_by_index(OCF_SEC_PSTAT, 0);
  oc_resource_set_observable(pstat_resource, false);
#endif

#ifdef INCLUDE_EXTERNAL_FUNCTION
  external_registration();
#endif
}

#ifdef OC_SECURITY
#ifdef OC_SECURITY_PIN
void
random_pin_cb(const unsigned char *pin, size_t pin_len, void *data)
{
  (void)data;
  PRINT("\n====================\n");
  PRINT("Random PIN: %.*s\n", (int)pin_len, pin);
  PRINT("====================\n");
}
#endif /* OC_SECURITY_PIN */
#endif /* OC_SECURITY */

/**
 * initiate preset for device
 *
 * @param device the device indentifier of the list of devices
 * @param data the supplied data.
 */
void
factory_presets_cb(size_t device, void *data)
{
  (void)device;
  (void)data;
#if defined(OC_SECURITY) && defined(OC_PKI)
/* code to include an pki certificate and root trust anchor */
#include "oc_pki.h"
#include "pki_certs.h"
  int credid =
    oc_pki_add_mfg_cert(0, (const unsigned char *)my_cert, strlen(my_cert), (const unsigned char *)my_key, strlen(my_key));
  if (credid < 0) {
    PRINT("ERROR installing PKI certificate\n");
  } else {
    PRINT("Successfully installed PKI certificate\n");
  }

  if (oc_pki_add_mfg_intermediate_cert(0, credid, (const unsigned char *)int_ca, strlen(int_ca)) < 0) {
    PRINT("ERROR installing intermediate CA certificate\n");
  } else {
    PRINT("Successfully installed intermediate CA certificate\n");
  }

  if (oc_pki_add_mfg_trust_anchor(0, (const unsigned char *)root_ca, strlen(root_ca)) < 0) {
    PRINT("ERROR installing root certificate\n");
  } else {
    PRINT("Successfully installed root certificate\n");
  }

  oc_pki_set_security_profile(0, OC_SP_BLACK, OC_SP_BLACK, credid);
#else
    PRINT("No PKI certificates installed\n");
#endif /* OC_SECURITY && OC_PKI */
}

/**
 * intializes the global variables
 * registers and starts the handler
 */
void
initialize_variables(void)
{
{%- if query_if_exist_all(json_data, "oic.if.startup") or query_if_exist_all(json_data, "oic.if.startup.revert") %}
  int ret_size = 0;
{%- endif %}
{%- for path, path_data in json_data['paths'].items() if "?" not in path %}
  /* initialize global variables for resource "{{path}}" */
{%- if query_if_exist(json_data, path, "oic.if.startup") or query_if_exist(json_data, path, "oic.if.startup.revert") %}
  oc_storage_read("g{{path|variablesyntax}}_storage_status", (uint8_t*)&g{{path|variablesyntax}}_storage_status, sizeof(g{{path|variablesyntax}}_storage_status));
{%- endif %}
{%- for var, var_data in query_properties_filtered(json_data, path).items() %}
{%- if var_data.type == "boolean" %}  
  g{{path|variablesyntax}}{{var|variablesyntax}} = {{swagger_property_data_schema(json_data, path, var)|init_value_if_empty(var_data.type)}}; /* current value of property "{{var}}" {{var_data["description"]}} */ 
  {%- if query_if_exist(json_data, path, "oic.if.startup") or query_if_exist_all(json_data, "oic.if.startup.revert") %}
  ret_size = oc_storage_read("g{{path|variablesyntax}}{{var|variablesyntax}}", (uint8_t*)&g{{path|variablesyntax}}{{var|variablesyntax}}, sizeof(g{{path|variablesyntax}}{{var|variablesyntax}}));
  if (ret_size != sizeof(g{{path|variablesyntax}}{{var|variablesyntax}}))
    PRINT (" could not read store g{{path|variablesyntax}}{{var|variablesyntax}} : %d\n", ret_size);
  {%- endif %}
{%- elif var_data.type == "number" %}
  g{{path|variablesyntax}}{{var|variablesyntax}} = {{swagger_property_data_schema(json_data, path, var)|init_value_if_empty(var_data.type)}}; /* current value of property "{{var}}"  {{var_data["description"]}} */
  {%- if query_if_exist(json_data, path, "oic.if.startup") or query_if_exist_all(json_data, "oic.if.startup.revert") %}
  ret_size = oc_storage_read("g{{path|variablesyntax}}{{var|variablesyntax}}", (uint8_t*)&g{{path|variablesyntax}}{{var|variablesyntax}}, sizeof(g{{path|variablesyntax}}{{var|variablesyntax}}));
  if (ret_size != sizeof(g{{path|variablesyntax}}{{var|variablesyntax}}))
    PRINT (" could not read store g{{path|variablesyntax}}{{var|variablesyntax}} : %d\n", ret_size);
  {%- endif %}
{%- elif var_data.type == "integer" %}
  g{{path|variablesyntax}}{{var|variablesyntax}} = {{swagger_property_data_schema(json_data, path, var)|init_value_if_empty(var_data.type)}}; /* current value of property "{{var}}" {{var_data["description"]}} */
  {%- if query_if_exist(json_data, path, "oic.if.startup") or query_if_exist_all(json_data, "oic.if.startup.revert") %}
  ret_size = oc_storage_read("g{{path|variablesyntax}}{{var|variablesyntax}}", (uint8_t*)&g{{path|variablesyntax}}{{var|variablesyntax}}, sizeof(g{{path|variablesyntax}}{{var|variablesyntax}}));
  if (ret_size != sizeof(g{{path|variablesyntax}}{{var|variablesyntax}}))
    PRINT (" could not read store g{{path|variablesyntax}}{{var|variablesyntax}} : %d\n", ret_size);
  {%- endif %}
{%- elif var_data.type == "string" %}
  strcpy(g{{path|variablesyntax}}{{var|variablesyntax}}, "{{swagger_property_data_schema(json_data, path, var)|init_value_if_empty(var_data.type)}}");  /* current value of property "{{var}}" {{var_data["description"]}} */
  {%- if query_if_exist(json_data, path, "oic.if.startup") or query_if_exist_all(json_data, "oic.if.startup.revert") %}
  ret_size = oc_storage_read("g{{path|variablesyntax}}{{var|variablesyntax}}", (uint8_t*)&g{{path|variablesyntax}}{{var|variablesyntax}}, MAX_STRING);
  if (ret_size <= 0)
    PRINT (" could not read store g{{path|variablesyntax}}{{var|variablesyntax}} : %d\n", ret_size);
  {%- endif %}
{%- elif var_data.type == "object" -%}
  /* object "{{var}}"initialized on zero & further initialization */
  memset((void*)&g{{path|variablesyntax}}{{var|variablesyntax}},0, sizeof(struct {{path|variablesyntax}}{{var|variablesyntax}}_t));
  {%- set my_string = 'g' ~ path|variablesyntax ~ var|variablesyntax  %}
  {%- set my_data = var_data.properties |get_c_data() %}
  {%- for k,v in my_data.items() %}
{%- if v[0] == "integer" %}  
  g{{path|variablesyntax}}{{var|variablesyntax}}.{{k}} = 0; 
{%- elif v[0] == "boolean" %}  
  g{{path|variablesyntax}}{{var|variablesyntax}}.{{k}} = true; 
{%- elif v[0] == "number" %}  
  g{{path|variablesyntax}}{{var|variablesyntax}}.{{k}} = 0.0 ; 
{% elif v[0] == "string" %}  
  strncpy(g{{path|variablesyntax}}{{var|variablesyntax}}.{{k}}, "blahblah" ,MAX_PAYLOAD_STRING-1); 
{%- elif v[0] == "string[]" %}  strncpy(g{{path|variablesyntax}}{{var|variablesyntax}}.{{k}}[0] , "blahblah[0]" ,MAX_PAYLOAD_STRING-1);
  g{{path|variablesyntax}}{{var|variablesyntax}}.{{k}}_array_size = 1 ;
{% else %}
    /* {{k}} not initialized */
{% endif %}
  {%- endfor %}
{%- elif var_data.type == "array" %}
  /* initialize array "{{var}}" : {{var_data["description"]}} */
  {%- if var_data |convert_to_cplus_array_type == "std::vector<std::string>" %}
  {%- for var_value in swagger_property_data_schema(json_data, path, var) %}  strncpy(g{{path|variablesyntax}}{{var|variablesyntax}}[{{loop.index0}}], "{{var_value}}", MAX_STRING-1);
  {%- endfor %}
  g{{path|variablesyntax}}{{var|variablesyntax}}_array_size = {{swagger_property_data_schema(json_data, path, var) | length }};
  {% elif var_data |convert_to_cplus_array_type == "std::vector<double>" -%}
  {%- for var_value in swagger_property_data_schema(json_data, path, var) %}
  g{{path|variablesyntax}}{{var|variablesyntax}}[{{loop.index0}}] = {{var_value}};
  {%- endfor %}
  g{{path|variablesyntax}}{{var|variablesyntax}}_array_size = {{swagger_property_data_schema(json_data, path, var) | length }};
  {% if swagger_property_data_schema(json_data, path, var) |length == 0 -%}
  {%- if var == "range" -%}
  /* no values found for range, adding default (double) range */
  g{{path|variablesyntax}}{{var|variablesyntax}}[0] = 0.0;
  g{{path|variablesyntax}}{{var|variablesyntax}}[1] = 100.0;
  g{{path|variablesyntax}}{{var|variablesyntax}}_array_size = 2;
  {%- endif %}{% endif %}
  {%- elif var_data |convert_to_cplus_array_type == "std::vector<int>" -%}
  {% for var_value in swagger_property_data_schema(json_data, path, var) -%}
  g{{path|variablesyntax}}{{var|variablesyntax}}[{{loop.index0}}] = {{var_value}};
  {% endfor -%}
  g{{path|variablesyntax}}{{var|variablesyntax}}_array_size = {{swagger_property_data_schema(json_data, path, var) | length }};
  {% if swagger_property_data_schema(json_data, path, var) |length == 0 -%}
  {%- if var == "range" -%}
  /* no values found for range, adding default (integer) range */
  g{{path|variablesyntax}}{{var|variablesyntax}}[0] = 0;
  g{{path|variablesyntax}}{{var|variablesyntax}}[1] = 100;
  g{{path|variablesyntax}}{{var|variablesyntax}}_array_size = 2;
  {%- endif -%}
  {% endif -%}
  {%- elif var_data |convert_to_cplus_array_type == "std::vector<bool>" -%}
  {%- for var_value in swagger_property_data_schema(json_data, path, var) %}
  g{{path|variablesyntax}}{{var|variablesyntax}}[{{loop.index0}}] = {{var_value|init_value_if_empty(var_data.type)}};
  {%- endfor %}
  g{{path|variablesyntax}}{{var|variablesyntax}}_array_size = {{swagger_property_data_schema(json_data, path, var) | length }};
  {%- elif var_data |convert_to_cplus_array_type == "std::vector<OCRepresentation>" %}
  memset((void*)&g{{path|variablesyntax}}{{var|variablesyntax}},0, sizeof(struct {{path|variablesyntax}}{{var|variablesyntax}}_t));
  {% set my_string = 'g' ~ path|variablesyntax ~ var|variablesyntax  %}
  {%- set my_data = var_data |get_c_data() %}
{%- for k,v in my_data.items() %}
{%- if v[0] == "integer" %}  g{{path|variablesyntax}}{{var|variablesyntax}}[0].{{k}} = 0; 
{% endif %}
{%- if v[0] == "boolean" %}  g{{path|variablesyntax}}{{var|variablesyntax}}[0].{{k}} = true; 
{% endif %}
{%- if v[0] == "number" %}  g{{path|variablesyntax}}{{var|variablesyntax}}[0].{{k}} = 0.0 ; 
{% endif %}
{%- if v[0] == "string" %}  strncpy(g{{path|variablesyntax}}{{var|variablesyntax}}[0].{{k}}, "blahblaha" ,MAX_PAYLOAD_STRING-1); 
{% endif %}
{%- if v[0] == "string[]" %}  strncpy(g{{path|variablesyntax}}{{var|variablesyntax}}[0].{{k}}[0], "blahblahaxx" ,MAX_PAYLOAD_STRING-1);
{% endif %}
{%- endfor %}
  g{{path|variablesyntax}}{{var|variablesyntax}}_array_size = 1;
  {% endif -%}
  {% endif -%}
  {% endfor -%}
  {%- endfor %}
  
  /* set the flag for NO oic/con resource. */
  oc_set_con_res_announced(false);
}

#ifndef NO_MAIN
#ifdef WIN32
/**
* signal the event loop (windows version)
* wakes up the main function to handle the next callback
*/
STATIC void
signal_event_loop(void)
{
  WakeConditionVariable(&cv);
}
#endif /* WIN32 */

#ifdef __linux__
/**
* signal the event loop (Linux)
* wakes up the main function to handle the next callback
*/
STATIC void
signal_event_loop(void)
{
  pthread_mutex_lock(&mutex);
  pthread_cond_signal(&cv);
  pthread_mutex_unlock(&mutex);
}
#endif /* __linux__ */

/**
* handle Ctrl-C
* @param signal the captured signal
*/
void
handle_signal(int signal)
{
  (void)signal;
  signal_event_loop();
  quit = 1;
}

#ifdef OC_CLOUD
/**
 * cloud status handler.
 * handler to print out the status of the cloud connection
 *
 * @param ctx the cloud context
 * @param status the status of the cloud connection
 * @param data the supplied user data.
*/
STATIC void
cloud_status_handler(oc_cloud_context_t *ctx, oc_cloud_status_t status,
                     void *data)
{
  (void)data;
  PRINT("\nCloud Manager Status:\n");
  if (status & OC_CLOUD_REGISTERED) {
    PRINT("\t\t-Registered\n");
  }
  if (status & OC_CLOUD_TOKEN_EXPIRY) {
    PRINT("\t\t-Token Expiry: ");
    if (ctx) {
      PRINT("%d\n", oc_cloud_get_token_expiry(ctx));
    } else {
      PRINT("\n");
    }
  }
  if (status & OC_CLOUD_FAILURE) {
    PRINT("\t\t-Failure\n");
  }
  if (status & OC_CLOUD_LOGGED_IN) {
    PRINT("\t\t-Logged In\n");
  }
  if (status & OC_CLOUD_LOGGED_OUT) {
    PRINT("\t\t-Logged Out\n");
  }
  if (status & OC_CLOUD_DEREGISTERED) {
    PRINT("\t\t-DeRegistered\n");
  }
  if (status & OC_CLOUD_REFRESHED_TOKEN) {
    PRINT("\t\t-Refreshed Token\n");
  }
}
#endif /* OC_CLOUD */

/**
 * oc_ownership_status_cb callback implementation
 * handler to print out the DI after onboarding
 *
 * @param device_uuid the device ID
 * @param device_index the index in the list of device IDs
 * @param owned owned or unowned indication
 * @param user_data the supplied user data.
*/
void oc_ownership_status_cb(const oc_uuid_t* device_uuid,
  size_t device_index, bool owned,
  void* user_data)
{
  (void)user_data;
  (void)device_index;
  (void)owned;

  char uuid[37] = { 0 };
  oc_uuid_to_str(device_uuid, uuid, OC_UUID_LEN);
  PRINT(" oc_ownership_status_cb: DI: '%s'\n", uuid);
}

/**
* main application.
* intializes the global variables
* registers and starts the handler
* handles (in a loop) the next event.
* shuts down the stack
*/
int
main(void)
{
int init;
  oc_clock_time_t next_event;

#ifdef WIN32
  /* windows specific */
  InitializeCriticalSection(&cs);
  InitializeConditionVariable(&cv);
  /* install Ctrl-C */
  signal(SIGINT, handle_signal);
#endif
#ifdef __linux__
  /* linux specific */
  struct sigaction sa;
  sigfillset(&sa.sa_mask);
  sa.sa_flags = 0;
  sa.sa_handler = handle_signal;
  /* install Ctrl-C */
  sigaction(SIGINT, &sa, NULL);
#endif

  PRINT("Used input file : \"{{input_file}}\"\n");
  PRINT("OCF Server name : \"{{json_data['info']['title']}}\"\n");

  char buff[FILENAME_MAX];
  char* retbuf = NULL;
  retbuf = GetCurrentDir(buff, FILENAME_MAX);
  if (retbuf != NULL)
  {
    PRINT("Current working dir: %s\n", buff);
  }

/*
 The storage folder depends on the build system
 for Windows the projects simpleserver and cloud_server are overwritten, hence the folders should be the same as those targets.
 for Linux (as default) the folder is created in the makefile, with $target as name with _cred as post fix.
*/
#ifdef OC_SECURITY
  PRINT("Intialize Secure Resources\n");
#ifdef WIN32
#ifdef OC_CLOUD
  PRINT("\tstorage at './cloudserver_creds' \n");
  oc_storage_config("./cloudserver_creds");
#else
  PRINT("\tstorage at './simpleserver_creds' \n");
  oc_storage_config("./simpleserver_creds/");
#endif
#else
  PRINT("\tstorage at './device_builder_server_creds' \n");
  oc_storage_config("./device_builder_server_creds");
#endif

  /*intialize the variables */
  initialize_variables();
  
#endif /* OC_SECURITY */

  /* initializes the handlers structure */
  STATIC const oc_handler_t handler = {.init = app_init,
                                       .signal_event_loop = signal_event_loop,
                                       .register_resources = register_resources
#ifdef OC_CLIENT
                                       ,
                                       .requests_entry = 0 
#endif
                                       };
#ifdef OC_SECURITY
#ifdef OC_SECURITY_PIN
  /* please enable OC_SECURITY_PIN
    - have display capabilities to display the PIN value
    - server require to implement RANDOM PIN (oic.sec.doxm.rdp) onboarding mechanism
  */
  oc_set_random_pin_callback(random_pin_cb, NULL);
#endif /* OC_SECURITY_PIN */
#endif /* OC_SECURITY */

  oc_set_factory_presets_cb(factory_presets_cb, NULL);
  
  /* start the stack */
  init = oc_main_init(&handler);

  if (init < 0) {
    PRINT("oc_main_init failed %d, exiting.\n", init);
    return init;
  }

#ifdef OC_CLOUD
  /* get the cloud context and start the cloud */
  PRINT("Start Cloud Manager\n");
  oc_cloud_context_t *ctx = oc_cloud_get_context(0);
  if (ctx) {
    oc_cloud_manager_start(ctx, cloud_status_handler, NULL);
  }
#endif 

  /* print out the current DI of the device */
  char uuid[37] = { 0 };
  oc_uuid_to_str(oc_core_get_device_id(0), uuid, OC_UUID_LEN);
  PRINT(" DI: '%s'\n", uuid);
  oc_add_ownership_status_cb(oc_ownership_status_cb, NULL);

  PRINT("OCF server \"{{json_data['info']['title']}}\" running, waiting on incoming connections.\n");

#ifdef WIN32
  /* windows specific loop */
  while (quit != 1) {
    next_event = oc_main_poll();
    if (next_event == 0) {
      SleepConditionVariableCS(&cv, &cs, INFINITE);
    } else {
      oc_clock_time_t now = oc_clock_time();
      if (now < next_event) {
        SleepConditionVariableCS(&cv, &cs,
                                 (DWORD)((next_event-now) * 1000 / OC_CLOCK_SECOND));
      }
    }
  }
#endif
  
#ifdef __linux__
  /* linux specific loop */
  while (quit != 1) {
    next_event = oc_main_poll();
    pthread_mutex_lock(&mutex);
    if (next_event == 0) {
      pthread_cond_wait(&cv, &mutex);
    } else {
      ts.tv_sec = (next_event / OC_CLOCK_SECOND);
      ts.tv_nsec = (next_event % OC_CLOCK_SECOND) * 1.e09 / OC_CLOCK_SECOND;
      pthread_cond_timedwait(&cv, &mutex, &ts);
    }
    pthread_mutex_unlock(&mutex);
  }
#endif

  /* shut down the stack */
#ifdef OC_CLOUD
  PRINT("Stop Cloud Manager\n");
  oc_cloud_manager_stop(ctx);
#endif
  oc_main_shutdown();
  return 0;
}
#endif /* NO_MAIN */
